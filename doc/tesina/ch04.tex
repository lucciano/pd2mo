	A continuación se presenta el pseudo código que implementa las transformaciones descriptas en este trabajo, 
	el código completo puede encontrarse en \url{https://github.com/lucciano/pd2mo}, el cual utiliza dos librerias, Modelica C Compiler 
	\footnote{http://sourceforge.net/projects/modelicacc/} el cual nos permite manipular la estructura de los modelos y evaluar los parámetros.
y libreria de PowerDEVS \footnote{http://sourceforge.net/projects/powerdevs/} para leer los archivos PDS.

El programa esta separado en 4 módulos:

\section{Programa Principal}

El Programa principal en el archivo main.cpp, el cual es responsable de la interfaz con el usuario (linea de comando) y lanzar la transformación de la simulación, asi como establecer los archivos desde donde se lee y hacia donde se escriben la simulación de powerDEVS y Modelica, respectivamente.


\begin{algorithm}[H]
\begin{algorithmic}[1]
\State modelCoupled *cm $\gets$ parsePDS(QString::fromStdString(src\_infile));
\State modelCoupled *qm $\gets$ flatter::flat(cm);
\State Pd2Mo q $\gets$ Pd2Mo();
\State q.transform(flatted, modelname, \&outfile, \&oFlogfile);
\State AST\_StoredDefinition sd $\gets$ parseFile(src\_outfile.c\_str(),\&amp;r);
\State mda *m $\gets$ new mda();
\State If *i $\gets$ new If();
\State outfile $\ll$ m$\rightarrow$\Call{visitClass} 
		{prod$\rightarrow$visitClass( i$\rightarrow$visitClass( 
			*sd$\rightarrow$models()$\rightarrow$begin()))} $\ll$ endl;

\end{algorithmic}
\caption{main(src\_infile)}
\end{algorithm}

\section{Transformación Principal}
La clase \emph{Pd2Mo} implementa las principales partes de la transformación.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\State modelCoupled *model $\gets$ parsePDS(qfilename);
\State AST\_ClassList classList $\gets$ getAsClassList(model); 
\State int j $\gets$ 0\;
\For{class en classList}
 	\If{La clase esta traducida a $\mu$Modelica}

 		\State Prefijamos las variables con el nombre del modelo $class$ y la posición $j$ que ocupan en la lista;
 		\State Remplazamos la entrada $class$ dentro de la lista por su copia producida en el paso anterior;
 	\EndIf
\EndFor
\State Creamos un modelo $modeloMo$;
\For{class en classList}
 	\State Combinamos el modelo $class$ con el $modeloMo$;
\EndFor

\For{ic en Conexión Interna del Modelo}
	\State Las conexiones ic estan definidas como dos pares de números, cada par señalan número  de modelo y número de puerto, en este caso los puertos deben ser desfasados en uno, pues los puertos en nuestra representación son los sub-indices de $u$ e $y$ para cada modelo, pero el primer elemento de los arreglos en Modelica comienzan.
  	\If{los modelos de ic son Escalares}
  		\State Se agrega la ecuación que representa la conexión entre los modelos;
  	\ElsIf{los modelos de ic son Vectoriales}
  		\State Se agregan $N$ ecuaciones indexadas por $i$ que representa la conexión, vectorial entre los modelos mediante una sentencia \texttt{For};
  	\Else
  		\State No se conoce la conexión;
	\EndIf
\EndFor
\end{algorithmic}
 \caption{Pd2Mo::transform()}
\end{algorithm}

\section{Aplanado de modelos acoplados}
La clase \emph{flatter} implementa el aplanado de los modelos acoplados.
 
\begin{algorithm}[H]
\begin{algorithmic}[1]
\For{ModeloHijo en Lista de Modelos}
  	\If{Tipo de ModeloHijo es COUPLED}
  		\For{ModeloHijo2 en Lista de ModeloHijo$\rightarrow$ModeloHijo}
  			 	\If{Tipo de ModeloHijo2 es ATOMIC}
  			 		\State Copiamos el ModeloHijo2 al ModeloResultado;
				\Else
  			 		\State Copiamos el aplanado de ModeloHijo2;
				\EndIf
  			 	\For{Conexión del Modelo}
  			 		\If{Si la conexión involucra un modelo \quotes{aun no procesado}}
  			 			\State Las conexiones deben ser modificadas teniendo en cuenta los modelos agregados en el aplanado;
					\EndIf
  			 		\If{Si la conexión involucra como destino el modelo acoplado ModeloHijo}
  			 			\State Se crea una nueva conexión (en ModeloResultado) entre los modelos agregado recientemente según la conexión del puerto de entrada del ModeloHijo y el origen de la conexión;
  			 			\State La conexión se marca para ser borrada;
					\EndIf
  			 		\If{Si la conexión involucra como origen el modelo acoplado ModeloHijo}
  			 			\State Se crea una nueva conexión (en ModeloResultado) entre los modelos agregado recientemente según la conexión del puerto de salida del ModeloHijo y el destino de la conexión;
  			 			\State La conexión se marca para ser borrada;
					\EndIf
  			 		\If{Si la conexión fue marcada}
						
						\State Se borra la conexión
					\EndIf
				\EndFor
		\EndFor
  	\Else

  		\State Copiamos el nodo ModeloHijo al ModeloResultado 
  		\State Copiamos las conexiones del ModeloHijo y cualquier otro ModeloHijo que ya haya sido procesado

	\EndIf
\EndFor
\Return ModeloResultado
\end{algorithmic}
\caption{flatter::flat}
\end{algorithm}

 
\section{Transformaciones para $\mu$-Modelica}
	 La clase \emph{mda}, \emph{prodint}, \emph{If} implementan transformaciones enfocadas en $\mu$-Modelica.
	 
	Tanto la clase $mda$, $prodint$ y $If$ recorren el árbol abstracto sintáctico (AST), por lo que cada clase es implementada heredando de una clase común 
	(Traverser), la cual retorna una copia del AST y remplaza una parte este.
	 
	  \begin{itemize}
		\item  $mda$: Remplaza expresiones de la forma \texttt{X[N,k]}, donde $k \in \mathbb{N}$ o evaluá a una variable que evaluá a una expresión 
			$\in \mathbb{N}$, es remplazado por \texttt{X\_k[N]}.

\begin{figure}[htp]
\centering
\begin{cminted}{modelica}
Real IndexShift_2_u[IndexShift_2_N,1];
\end{cminted}

$\Downarrow$

\begin{cminted}{modelica}
Real IndexShift_2_u_1[IndexShift_2_N];
\end{cminted}
\end{figure}


		\item $prodint$: Remplaza expresiones de la forma $u[i, 1:nin] * w$ por expresiones de la forma 
			u[i,1] * w[1] + u[i,2] * w[2] .... + u[i,nin] * w[nin], donde $nin \in \mathbb{N}$ o evaluá a una variable que evaluá a una 
			expresión $\in \mathbb{N}$
		
		\item $If$: Remplaza expresiones de la forma $if(v){eq_1}else{eq_2}$ si $v$ evaluá a un booleano (a partir de parámetros o constantes, 
			es decir en análisis estático) se remplaza por $eq_1$ o $eq_2$ si es $v$ es verdadero o falso respectivamente.
	  \end{itemize}
