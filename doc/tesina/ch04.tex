	A continuación se presenta el pseudo código que implementa las transformaciones descriptas en este trabajo, 
	el código completo puede encontrarse en \url{https://github.com/lucciano/pd2mo}, el cual utiliza dos librerias, Modelica C Compiler 
	\footnote{http://sourceforge.net/projects/modelicacc/} el cual nos permite manipular la estructura de los modelos y evaluar los parámetros.
	y libreria de PowerDEVS \footnote{http://sourceforge.net/projects/powerdevs/} para leer los archivos PDS.


\section{Programa Principal}

El Programa principal en el archivo main.cpp, el cual es responsable de la interfaz con el usuario (linea de comando) y lanzar la transformación de la simulación, así como establecer los archivos desde donde se lee y hacia donde se escriben la simulación de PowerDEVS y Modelica, respectivamente.

La transformación de la simulación se encuentra separada en disitintos modulos los cuales funcionan como una linea aplicandose uno detras del otro, lo cual se intenta
describir en la figura \ref{fig:pipeline}.
\begin{figure}[H]
\centerfloat
\smartdiagramset{
uniform color list=gray!60!black for 6 items,
back arrow disabled=true,
}
\smartdiagram[flow diagram:horizontal]{Parseo,Aplanado,Transformación Principal,Arreglo Bidimensionales,Construcciones If,Producto Interno}
\caption{Esquema de tranformaciones aplicadas}
\label{fig:pipeline}
\end{figure}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\State modelCoupled *cm $\gets$ parsePDS(QString::fromStdString(src\_infile));
\State modelCoupled *qm $\gets$ flatter::flat(cm);
\State Pd2Mo q $\gets$ Pd2Mo();
\State q.transform(flatted, modelname, \&outfile, \&oFlogfile);
\State AST\_StoredDefinition sd $\gets$ parseFile(src\_outfile.c\_str(),\&amp;r);
\State mda *m $\gets$ new mda();
\State If *i $\gets$ new If();
\State outfile $\ll$ m$\rightarrow$\Call{visitClass} 
		{prod$\rightarrow$visitClass( i$\rightarrow$visitClass( 
			*sd$\rightarrow$models()$\rightarrow$begin()))} $\ll$ endl;

\end{algorithmic}
\caption{main(src\_infile)}
\end{algorithm}

\section{Aplanado de modelos acoplados} 
La clase \emph{flatter} implementa el aplanado de los modelos acoplados descripto en la sección \ref{aplanado}.
 
\begin{algorithm}[H]
\begin{algorithmic}[1]
\For{ModeloHijo en Lista de Modelos}
  	\If{Tipo de ModeloHijo es COUPLED}
  		\For{ModeloHijo2 en Lista de ModeloHijo$\rightarrow$ModeloHijo}
  			 	\If{Tipo de ModeloHijo2 es ATOMIC}
  			 		\State Copiamos el ModeloHijo2 al ModeloResultado;
				\Else
  			 		\State Copiamos el aplanado de ModeloHijo2;
				\EndIf
				\State posicionModelo $\gets$ Posicion del ModeloHijo en el Modelo
  			 	\For{Conexión Interna ic del Modelo}
					\State (x,u);(y,v) $\gets$ ic
  			 		\Comment{Si la conexión involucra un modelo \quotes{aun no procesado}}
					\If{x > posicionModelo}
						\State x $\gets$ x + posicionModelo
					\EndIf
					\If{y > posicionModelo}
						\State y $\gets$ y + posicionModelo
					\EndIf

  			 		\If{Si la conexión involucra como destino el modelo acoplado ModeloHijo}
  			 			\Comment{Se crea una nueva conexión (en ModeloResultado) entre los modelos agregado recientemente según la conexión del puerto de entrada del ModeloHijo y el origen de la conexión}
						\For{Conexión Externa Entrante eic del ModeloHijo}
							\State (0,u1);(x1,v1) $\gets$ eic
							\If{u1 $==$ v}
								\State icadd $\gets$ (x,u);(x1+posicionModelo,v1)
								\State Agregamos icadd a las conexión del Modelo
							\EndIf
						\EndFor
  			 			\State La conexión se marca para ser borrada;
					\EndIf
  			 		\If{Si la conexión involucra como origen el modelo acoplado ModeloHijo}
  			 			\Comment{Se crea una nueva conexión (en ModeloResultado) entre los modelos agregado recientemente según la conexión del puerto de salida del ModeloHijo y el destino de la conexión}
						\For{Conexión Externa Saliente eoc del ModeloHijo}
							\State (x1,u1);(0,v1) $\gets$ eic
							\If{v1 $==$ u}
								\State icadd $\gets$ (x1+posicionModelo,u1);(y,v)
								\State Agregamos icadd a las conexión del Modelo
							\EndIf

						\EndFor

  			 			\State La conexión se marca para ser borrada;
					\EndIf
  			 		\If{Si la conexión fue marcada para ser borrada}
						\State Se borra la conexión
					\EndIf
				\EndFor
		\EndFor
  	\Else

  		\State Copiamos el nodo ModeloHijo al ModeloResultado 
  		\State Copiamos las conexiones del ModeloHijo y cualquier otro ModeloHijo que ya haya sido procesado

	\EndIf
\EndFor
\Return ModeloResultado
\end{algorithmic}
\caption{flatter::flat}
\end{algorithm}

\section{Transformación Principal}
La clase \emph{Pd2Mo} implementa las principales partes de la transformación, la cual incluye abrir el archivo PDS, e invocar el aplanado, obtener los diferentes modelos modelica que representan los modelos atómico, prevenir la colisión de nombres, crear el modelo final y realizar las conexiones.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\State modelCoupled *model $\gets$ parsePDS(qfilename);
\State AST\_ClassList classList $\gets$ getAsClassList(model); 
\State int j $\gets$ 0\;
\For{class en classList}
 	\If{La clase esta traducida a $\mu$Modelica}

 		\State Prefijamos las variables con el nombre del modelo $class$ y la posición $j$ que ocupan en la lista;
 		\State Remplazamos la entrada $class$ dentro de la lista por su copia producida en el paso anterior;
 	\EndIf
\EndFor
\State Creamos un modelo $modeloMo$;
\For{class en classList}
 	\State Combinamos el modelo $class$ con el $modeloMo$;
\EndFor

\For{ic en Conexión Interna del Modelo}
	\State (x,u)(y,j) $\gets$ ic
	\State u $\gets$ u + 1
	\Comment{ Se incrementa el orden de los puerto, ya que Modelica los arreglos comienzan en 1}
	\State j $\gets$ j + 1
  	\If{los modelos de ic son Escalares}
  		\State Se agrega la ecuación que representa la conexión entre los modelos x con el puerto u y el modelo y con el puerto j;
  	\ElsIf{los modelos de ic son Vectoriales}
  		\State Se agregan $N$ ecuaciones indexadas por $i$ que representa la conexión, vectorial entre los modelos u y j mediante una sentencia \texttt{For};
  	\Else
  		\State No se conoce la conexión;
	\EndIf
\EndFor
\end{algorithmic}
 \caption{Pd2Mo::transform()}
\end{algorithm}

 
\section{Transformaciones para $\mu$-Modelica} \label{sec:transform}
	Tanto la clase \texttt{mda}, \texttt{prodint} y \texttt{If} son implementadas con el patrón de diseño de visitadores sobre 
	el árbol sintáctico abstracto\footnote{un árbol de sintaxis abstracta (AST), o simplemente un árbol de sintaxis, es una representación 
	de árbol de la estructura sintáctica abstracta (simplificada) del código fuente escrito en cierto lenguaje de programación.}, por lo que 
	cada clase es implementada heredando de una clase común (\texttt{Traverser}), la cual retorna una copia del AST y remplaza una parte de este según sea el 
	objetivo de la clase.
	
	Estas transformaciones son necesarias dado que al momento de realizar este trabajo algunas expresiones Modelica no eran soportadas por el QSS-Solver.
	 
	  \begin{itemize}
		\item  \texttt{mda}: Remplaza expresiones de la forma \texttt{X[N,k]}, donde $k \in \mathbb{N}$ o evalúa a una variable que evalúa a una expresión 
			$\in \mathbb{N}$, es remplazado por \texttt{X\_k[N]} en las secciones \texttt{equation}, \texttt{algorithm}, \texttt{initial algorithm} y 
		declaraciones para hacer el código Modelica valido. En otras palabras remplaza arreglos bidimensionales por arreglos unidimensionales.

\begin{figure}[htp]
\centering
\begin{cminted}{modelica}
Real IndexShift_2_u[IndexShift_2_N,1];
\end{cminted}

$\Downarrow$

\begin{cminted}{modelica}
Real IndexShift_2_u_1[IndexShift_2_N];
\end{cminted}
\end{figure}

		\item $prodint$: Remplaza expresiones de la forma $u[i, 1:nin] * w$ por expresiones de la forma 
			u[i,1] * w[1] + u[i,2] * w[2] .... + u[i,nin] * w[nin], donde $nin \in \mathbb{N}$ o evaluá a una variable que evaluá a una 
			expresión $\in \mathbb{N}$, es decir expande la operación de producto interno ($*$) entre los dos vectores.

\begin{figure}[htp]
\centering
\begin{minted}{modelica}
    VectorSum_3_y_1[VectorSum_3_i] = 
	VectorSum_3_u[VectorSum_3_i, 1:VectorSum_3_nin] * VectorSum_3_w;
\end{minted}

	(Donde \texttt{VectorSum\_3\_nin = 4}  y \texttt{VectorSum\_3\_w} tiene dimensión 4, lo que es necesario para que quede definida el producto de dos 
	vectores en modelica.)

$\Downarrow$

\begin{minted}{modelica}
    VectorSum_3_y[1,VectorSum_3_i] = 
	VectorSum_3_u[1,VectorSum_3_i]*VectorSum_3_w[1]+
	VectorSum_3_u[2,VectorSum_3_i]*VectorSum_3_w[2]+
	VectorSum_3_u[3,VectorSum_3_i]*VectorSum_3_w[3]+
	VectorSum_3_u[4,VectorSum_3_i]*VectorSum_3_w[4];
\end{minted}
\end{figure}

		\item $If$: Remplaza expresiones de la forma $if(v){eq_1}else{eq_2}$ si $v$ evaluá a un booleano (a partir de parámetros o constantes, 
			es decir en análisis estático) se remplaza por $eq_1$ o $eq_2$ si es $v$ es verdadero o falso respectivamente.

\begin{figure}[htp]
\centering
\begin{minted}{modelica}
  if IndexShift_2_Shift > 0 then
    for IndexShift_2_i in 1:IndexShift_2_N-IndexShift_2_Shift loop
      IndexShift_2_y_1[IndexShift_2_i+IndexShift_2_Shift] = 
	IndexShift_2_u_1[IndexShift_2_i];
    end for;
    for IndexShift_2_i in 1:IndexShift_2_Shift loop
      IndexShift_2_y_1[IndexShift_2_i] = 0;
    end for;
  else
    for IndexShift_2_i in 1:IndexShift_2_N-IndexShift_2_Shift loop
      IndexShift_2_y_1[IndexShift_2_i] = 
		IndexShift_2_u_1[IndexShift_2_i - +IndexShift_2_Shift];
    end for;
    for IndexShift_2_i in IndexShift_2_N + IndexShift_2_Shift : IndexShift_2_N loop
      IndexShift_2_y_1[IndexShift_2_i] = 0;
    end for;
  end if;
\end{minted}

(Con \texttt{Shift $> 0$})

$\Downarrow$

\begin{minted}{modelica}
  for IndexShift_2_i in 1:IndexShift_2_N-IndexShift_2_Shift loop
    IndexShift_2_y_1[IndexShift_2_i+IndexShift_2_Shift] = 
	IndexShift_2_u_1[IndexShift_2_i];
  end for;
  for IndexShift_2_i in 1:IndexShift_2_Shift loop
    IndexShift_2_y_1[IndexShift_2_i] = 0;
  end for;
\end{minted}
\end{figure}
	  \end{itemize}
